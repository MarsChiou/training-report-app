const functions = require("firebase-functions");
const fetch = require("node-fetch");
const admin = require("firebase-admin");
const axios = require("axios");
const {onRequest} = require("firebase-functions/v2/https");
const {defineSecret} = require("firebase-functions/params");
const LINE_CHANNEL_ACCESS_TOKEN = defineSecret("LINE_CHANNEL_ACCESS_TOKEN");

if (!admin.apps.length) {
  admin.initializeApp();
}

const db = admin.firestore();

const CACHE_TTL = {
  movementLib: 12 * 60 * 60 * 1000, // 12 hours
  trainingProgress: 12 * 60 * 60 * 1000, // 12 hours
};

const GAS_BASE_URL ="https://script.google.com/macros/s/AKfycbzcf0YKfJksPgxBbNT-5ElE11Rz13H5D1hsm5dT1k0W8WptQ62HpbYLlqf54ImkNlefKw/exec";
const GAS_META_URL = `${GAS_BASE_URL}?action=meta`;
const GAS_NAMES_URL = `${GAS_BASE_URL}?action=names&format=object`;
const GAS_MOVEMENT_LIB_URL = `${GAS_BASE_URL}?action=movementLib`;
const GAS_PROGRESS_URL = `${GAS_BASE_URL}?action=progress`;
// Diary with cache (GET /proxyDiaryWithCache?userId=...&fresh=1 ÂèØÁπûÈÅéÂø´Âèñ)
const CACHE_TTL_DIARY = 24 * 60 * 60 * 1000;
const GAS_DIARY_URL = `${GAS_BASE_URL}?action=diary`;

if (!GAS_BASE_URL) {
  throw new Error("‚ùå GAS_BASE_URL Êú™ÂÆöÁæ©");
}

// Âª∫Á´ã‰∏ÄÂÄã HTTPS Cloud Function ‰ΩúÁÇ∫‰ª£ÁêÜ
exports.proxyToGAS = functions
    .https.onRequest(async (req, res) => {
      res.set("Access-Control-Allow-Origin", "*");
      res.set("Access-Control-Allow-Methods", "POST, OPTIONS");
      res.set("Access-Control-Allow-Headers", "Content-Type");

      if (req.method === "OPTIONS") {
        return res.status(204).send("");
      }

      if (req.method !== "POST") {
        return res.status(405).send("Method Not Allowed");
      }

      // Log Áî®Ë≥áÊñô
      const requestData = req.body;
      const timestampUTC = new Date();
      const timestampTaiwan = new Date(timestampUTC.
          getTime() + 8 * 60 * 60 * 1000);

      const dateString = timestampTaiwan.
          toISOString().split("T")[0]; // e.g., "2025-05-05"
      const timeString = timestampTaiwan.
          toTimeString().split(" ")[0]; // e.g., "14:25:36"
      const logId = `${timeString}_${requestData.userId || "unknow"}`; // doc ID

      let gasResponseText = "";
      let errorMessage = "";

      //
      try {
        const gasResponse = await fetch(GAS_BASE_URL, {
          method: "POST",
          headers: {"Content-Type": "application/json"},
          body: JSON.stringify(requestData),
        });

        gasResponseText = await gasResponse.text();
        res.status(200).send(gasResponseText);
        // === Ëã•ÂõûÂ†±ÊàêÂäü‰∏îÂê´Êó•Ë®ò ‚Üí Â§±ÊïàÊó•Ë®òÂø´Âèñ ===
        const ok = gasResponse.ok && gasResponseText &&
          !gasResponseText.startsWith("‚ùå") &&
          !gasResponseText.includes("ÈåØË™§");
        const diaryText = String(requestData.diaryText || "").trim();
        const diaryDone = !!requestData.diaryDone;

        if (ok && (diaryText.length > 0 || diaryDone)) {
          try {
            const cacheSnap = await db.collection("cache").get();
            const batch = db.batch();
            let cnt = 0;
            cacheSnap.forEach((doc) => {
              if (doc.id.startsWith("diary_")) {
                batch.delete(doc.ref);
                cnt++;
              }
            });
            if (cnt > 0) await batch.commit();
            console.log(`üßπ Diary cache invalidated, count=${cnt}`);
          } catch (invErr) {
            console.error("invalidate diary cache failed", invErr);
            // ‰∏çÂΩ±Èüø‰∏ªÊµÅÁ®ã
          }
        }
      } catch (err) {
        errorMessage = err.message;
        console.error("ËΩâÈÄÅÂ§±Êïó", err);
        res.status(500).send("ÁôºÁîüÈåØË™§Ôºö" + errorMessage);
      } finally {
        try {
          await db
              .collection("postLogs")
              .doc(dateString) // ÊØèÂ§©‰∏Ä‰ªΩÊñá‰ª∂
              .collection("entries") // subcollection Ë£°ÊØèÁ≠Ü log
              .doc(logId) // ÂèØÈÅøÂÖçÈáçË§áÔºàÁêÜË´ñ‰∏ä‰∏çÂ§™ÊúÉÊíûÔºâ
              .set({
                requestData,
                gasResponse: gasResponseText,
                errorMessage,
                timestampUTC: timestampUTC.toISOString(),
                timestampTaiwan: timestampTaiwan.toLocaleString("zh-TW"),
              });
        } catch (logErr) {
          console.error("ÂØ´ÂÖ• Firestore log ÊôÇÂ§±Êïó", logErr);
        }
      }
    });

// Âãï‰ΩúÂúñÂ∫´ÂäüËÉΩ
exports.proxyMovementLibWithCache = functions
    .https.onRequest(async (req, res) => {
      res.set("Access-Control-Allow-Origin", "*");
      res.set("Access-Control-Allow-Methods", "GET, OPTIONS");
      res.set("Access-Control-Allow-Headers", "Content-Type");

      if (req.method === "OPTIONS") {
        res.status(204).send("");
        return;
      }

      try {
        const cacheDocRef = db.collection("cache").doc("movementLib");
        const cacheDoc = await cacheDocRef.get();
        const now = Date.now();
        const ttl = CACHE_TTL.movementLib;

        if (cacheDoc.exists) {
          const {lastUpdate, data} = cacheDoc.data();
          if (now - new Date(lastUpdate).getTime() < ttl) {
            res.status(200).json(data);
            return;
          }
        }

        const response = await fetch(GAS_MOVEMENT_LIB_URL);
        const contentType = response.headers.get("Content-Type");

        if (!contentType || !contentType.includes("application/json")) {
          const text = await response.text();
          console.error("‚ùå GAS ÂõûÂÇ≥Èùû JSONÔºö", text.slice(0, 200));
          return res.status(502).send("GAS ÂõûÂÇ≥ÈåØË™§ÔºåË´ãÈáçÊñ∞Ê™¢Êü•ÈÉ®ÁΩ≤ËàáÊéàÊ¨äË®≠ÂÆö");
        }

        const freshData = await response.json();

        await cacheDocRef.set({
          lastUpdate: new Date().toISOString(),
          data: freshData,
        });

        res.status(200).json(freshData);
      } catch (error) {
        console.error("Error in proxyMovementLibWithCache:", error);
        res.status(500).send("Server error");
      }
    });

exports.proxyTrainingProgressWithCache = functions
    .https.onRequest(async (req, res) => {
      res.set("Access-Control-Allow-Origin", "*");
      res.set("Access-Control-Allow-Methods", "GET, OPTIONS");
      res.set("Access-Control-Allow-Headers", "Content-Type");

      if (req.method === "OPTIONS") {
        res.status(204).send("");
        return;
      }

      try {
        const cacheDocRef = db.collection("cache").doc("trainingProgress");
        const cacheDoc = await cacheDocRef.get();
        const now = Date.now();
        const ttl = CACHE_TTL.trainingProgress;

        if (cacheDoc.exists) {
          const {lastUpdate, data} = cacheDoc.data();
          if (now - new Date(lastUpdate).getTime() < ttl) {
            res.status(200).json(data);
            return;
          }
        }

        const response = await fetch(GAS_PROGRESS_URL);
        const contentType = response.headers.get("Content-Type");

        if (!contentType || !contentType.includes("application/json")) {
          const text = await response.text();
          console.error("‚ùå GAS ÂõûÂÇ≥Èùû JSONÔºö", text.slice(0, 200));
          return res.status(502).send("GAS ÂõûÂÇ≥ÈåØË™§ÔºåË´ãÈáçÊñ∞Ê™¢Êü•ÈÉ®ÁΩ≤ËàáÊéàÊ¨äË®≠ÂÆö");
        }

        const freshData = await response.json();

        await cacheDocRef.set({
          lastUpdate: new Date().toISOString(),
          data: freshData,
        });

        res.status(200).json(freshData);
      } catch (error) {
        console.error("Error in proxyTrainingProgressWithCache:", error);
        res.status(500).send("Server error");
      }
    });

exports.proxyDiaryWithCache = functions.https.onRequest(async (req, res) => {
  // CORS
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "GET, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type");

  if (req.method === "OPTIONS") return res.status(204).send("");
  if (req.method !== "GET") {
    return res.status(405).json({ok: false, error: "Method Not Allowed"});
  }

  try {
    const userId = String(req.query.userId || "").trim();
    if (!userId) {
      return res.status(400).json({ok: false, error: "Missing userId"});
    }

    const start = req.query.start ? String(req.query.start) : "";
    const end = req.query.end ? String(req.query.end) : "";
    const fresh = String(req.query.fresh || "") === "1";

    const cacheId = `diary_${userId}${start || end ?
      `_${start}_${end}` : ""}`;
    const cacheRef = db.collection("cache").doc(cacheId);

    // fresh=1 ‚Üí Áõ¥Êé•Êâì GAS ‰∏¶ÂõûÂ°´Âø´Âèñ
    if (fresh) {
      const out = await fetchDiaryFromGASAndCache(GAS_DIARY_URL,
          {userId, start, end}, cacheRef);
      return res.status(out.status).json(out.body);
    }

    // ÂÖàÁúãÂø´Âèñ
    const snap = await cacheRef.get();
    const now = Date.now();

    if (snap.exists) {
      const {lastUpdate, data} = snap.data();
      if (data && (now - new Date(lastUpdate).getTime()) < CACHE_TTL_DIARY) {
        return res.status(200).json(data);
      }
    }

    // Ê≤íÂø´ÂèñÊàñÈÅéÊúü ‚Üí Âèñ GAS + ÂõûÂ°´
    const out = await fetchDiaryFromGASAndCache(GAS_DIARY_URL,
        {userId, start, end}, cacheRef);
    return res.status(out.status).json(out.body);
  } catch (err) {
    console.error("proxyDiaryWithCache error", err);
    return res.status(500).json({ok: false,
      error: String(err?.message || err)});
  }
});

exports.proxyRosterWithCache = functions.https.onRequest(async (req, res) => {
  // CORS
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "GET, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type");
  if (req.method === "OPTIONS") return res.status(204).send("");
  if (req.method !== "GET") {
    return res.status(405).json({ok: false, error: "Method Not Allowed"});
  }

  const fresh = String(req.query.fresh || "") === "1";

  try {
    // 1) ÂÖàÊãø metaÔºàÂèñÂæó campId + rosterVersionÔºâ
    const meta = await fetchJSONorThrow(GAS_META_URL);
    if (!meta?.ok || !meta?.campId) {
      return res.status(502).json({ok: false, error: "meta Â§±Êïó"});
    }
    const campId = String(meta.campId);
    const version = String(meta.rosterVersion || "");

    const docId = `roster_${campId}`;
    const ref = db.collection("cache").doc(docId);

    // 2) Èùû fresh ‚Üí ÂòóË©¶ÂëΩ‰∏≠Âø´ÂèñÔºàÂè™ÁúãÁâàÊú¨Ôºå‰∏çÁúã TTLÔºâ
    if (!fresh) {
      const snap = await ref.get();
      if (snap.exists) {
        const c = snap.data();
        if (c && c.version === version && Array.isArray(c.data)) {
          return res.status(200).json({
            ok: true, campId, version, roster: c.data, source: "cache",
            lastUpdate: c.lastUpdate || null,
          });
        }
      }
    }

    // 3) ÂèñÊñ∞ÁöÑÂêçÂñÆ
    const list = await fetchJSONorThrow(GAS_NAMES_URL);
    if (!Array.isArray(list)) {
      return res.status(502).json({ok: false, error: "names Ê†ºÂºèÈåØË™§ÔºàÈùûÈô£ÂàóÔºâ"});
    }

    // 4) Ë¶ÜÂØ´Âø´ÂèñÔºàÁâàÊú¨Ë∑üËëó metaÔºâ
    await ref.set({
      version,
      data: list,
      lastUpdate: new Date().toISOString(),
    }, {merge: true});

    return res.status(200).json({
      ok: true, campId, version, roster: list, source: "fresh",
    });
  } catch (e) {
    console.error("proxyRosterWithCache error", e);
    return res.status(500).json({ok: false, error: String(e.message || e)});
  }
});

/**
*@param {string} url - TheURL
*/
async function fetchJSONorThrow(url) {
  const r = await fetch(url);
  const ctype = r.headers.get("Content-Type") || "";
  if (!ctype.includes("application/json")) {
    const peek = await r.text();
    throw new Error(`GAS returned non-JSON: ${peek.slice(0, 200)}`);
  }
  return r.json();
}

/**
 * Fetch diary data from GAS and update cache
 * @param {string} baseUrl - The base URL for GAS
 * @param {Object} params - Parameters object
 * @param {string} params.userId - User ID
 * @param {string} params.start - Start date
 * @param {string} params.end - End date
 * @param {Object} cacheRef - Firestore cache reference
 * @return {Promise<Object>} Response object with status and body
 */
async function fetchDiaryFromGASAndCache(baseUrl, {userId, start, end},
    cacheRef) {
  const qs = new URLSearchParams({userId});
  if (start) qs.set("start", start);
  if (end) qs.set("end", end);

  const url = `${baseUrl}&${qs.toString()}`;
  const r = await fetch(url);
  const ctype = r.headers.get("Content-Type") || "";
  if (!ctype.includes("application/json")) {
    const text = await r.text();
    return {status: 502, body: {ok: false, error: "GAS returned non-JSON",
      peek: text.slice(0, 200)}};
  }

  const json = await r.json();
  if (json && json.ok) {
    await cacheRef.set({lastUpdate: new Date().toISOString(),
      data: json}, {merge: true});
  }
  return {status: 200, body: json};
}

// Âº∑Âà∂Êõ¥Êñ∞Ë®ìÁ∑¥ÈÄ≤Â∫¶
exports.forceUpdateTrainingProgressCache = functions
    .https.onRequest(async (req, res) => {
      res.set("Access-Control-Allow-Origin", "*");
      res.set("Access-Control-Allow-Methods", "POST, OPTIONS");
      res.set("Access-Control-Allow-Headers", "Content-Type");

      if (req.method === "OPTIONS") {
        res.status(204).send("");
        return;
      }

      try {
        const response = await fetch(GAS_PROGRESS_URL);
        const contentType = response.headers.get("Content-Type");

        if (!contentType || !contentType.includes("application/json")) {
          const text = await response.text();
          console.error("‚ùå GAS ÂõûÂÇ≥Èùû JSONÔºö", text.slice(0, 200));
          return res.status(502).send("GAS ÂõûÂÇ≥ÈåØË™§ÔºåË´ãÈáçÊñ∞Ê™¢Êü•ÈÉ®ÁΩ≤ËàáÊéàÊ¨äË®≠ÂÆö");
        }

        const freshData = await response.json();

        const cacheDocRef = db.collection("cache").doc("trainingProgress");
        await cacheDocRef.set({
          lastUpdate: new Date().toISOString(),
          data: freshData,
        });

        // ‚úÖ Ê∏ÖÈô§ movementLib Âø´Âèñ
        await db.collection("cache").doc("movementLib").delete();
        console.log("üßπ Â∑≤Ê∏ÖÈô§ movementLib Âø´Âèñ");

        console.log("‚úÖ Ë®ìÁ∑¥ÈÄ≤Â∫¶Âø´ÂèñÂ∑≤Âº∑Âà∂Êõ¥Êñ∞");
        res.status(200).send("‚úÖ Ë®ìÁ∑¥ÈÄ≤Â∫¶Âø´ÂèñÂ∑≤Âº∑Âà∂Êõ¥Êñ∞");
      } catch (error) {
        console.error("üî• Âº∑Âà∂Êõ¥Êñ∞ÈåØË™§Ôºö", error);
        res.status(500).send("‚ùå Âº∑Âà∂Êõ¥Êñ∞Â§±Êïó");
      }
    });

// Line Web Hook Server
exports.lineWebhook = onRequest(
    {secrets: [LINE_CHANNEL_ACCESS_TOKEN]}, async (req, res) => {
      const event = req.body.events?.[0];
      if (!event || event.type !== "message" || event.message.type !== "text") {
        return res.status(200).send("Not a valid text message");
      }

      const message = event.message.text;
      const replyToken = event.replyToken;
      const trainingProgressUrl = "https://us-central1-joi-team.cloudfunctions" +
        ".net/forceUpdateTrainingProgressCache";

      if (message === "/Êõ¥Êñ∞Âãï‰ΩúÈÄ≤Â∫¶") {
        try {
          const response = await fetch(trainingProgressUrl, {method: "POST"});
          const resultText = await response.text();

          await reply(replyToken, resultText);
          return res.status(200).send("Êõ¥Êñ∞ÈÄ≤Â∫¶ÊàêÂäü");
        } catch (err) {
          console.error("üî• ÂëºÂè´ Firebase Function Â§±Êïó", err);
          await reply(replyToken, "‚ùå Êõ¥Êñ∞ÈÄ≤Â∫¶Â§±Êïó");
          return res.status(500).send("Êõ¥Êñ∞Â§±Êïó");
        }
      } else {
        await reply(replyToken, "ÈÄôÂÄãÊåá‰ª§Êàë‰∏çË™çË≠òÂñî~");
        return res.status(200).send("Â∑≤ËôïÁêÜË®äÊÅØ");
      }
    });

/**
 * ÂõûË¶ÜË®äÊÅØÁµ¶‰ΩøÁî®ËÄÖ
 * @param {string} replyToken - LINE ÂõûË¶Ü token
 * @param {string} text - Ë¶ÅÂõûË¶ÜÁöÑÊñáÂ≠ó
 * @return {Promise} - axios POST ÂõûÊáâ promise
 */
async function reply(replyToken, text) {
  const token = LINE_CHANNEL_ACCESS_TOKEN.value();
  console.log("‚úÖ ÂèñÂæóÁöÑ token Èï∑Â∫¶:", token?.length);
  return axios.post(
      "https://api.line.me/v2/bot/message/reply",
      {
        replyToken,
        messages: [{type: "text", text}],
      },
      {
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${LINE_CHANNEL_ACCESS_TOKEN.value()}`,
        },
      },
  );
}
